php缓存技术——memcache常用函数详解
php缓存技术——memcache常用函数详解
2016-04-07 aileen PHP编程

Memcache函数库是在PECL(PHP Extension Community Library)中，主要作用是搭建大容量的内存数据的临时存放区域，在分布式的时候作用体现的非常明显，否则不建议使用。
 
memcache 函数所有的方法列表如下：
参考http://www.php.net/manual/zh/function.Memcache-add.php
 
Memcache::add - 添加一个值，如果已经存在，则返回false
Memcache::addServer - 添加一个可供使用的服务器地址
Memcache::close - 关闭一个Memcache对象
Memcache::connect - 创建一个Memcache对象
memcache_debug - 控制调试功能
Memcache::decrement - 对保存的某个key中的值进行减法操作
Memcache::delete - 删除一个key值
Memcache::flush - 清除所有缓存的数据
Memcache::get - 获取一个key值
Memcache::getExtendedStats - 获取进程池中所有进程的运行系统统计
Memcache::getServerStatus - 获取运行服务器的参数
Memcache::getStats - 返回服务器的一些运行统计信息
Memcache::getVersion - 返回运行的Memcache的版本信息
Memcache::increment - 对保存的某个key中的值进行加法操作
Memcache::pconnect - 创建一个Memcache的持久连接对象
Memcache::replace -对一个已有的key进行覆写操作
Memcache::set - 添加一个值，如果已经存在，则覆写
Memcache::setCompressThreshold - 对大于某一大小的数据进行压缩
Memcache::setServerParams - 在运行时修改服务器的参数
 
Memcache::add 用法
bool Memcache::add ( string $key , mixed $var [, int $flag [, int $expire ]] )
说明：
如果$key不存在的时候，使用这个函数来存储$var的值。功能相同的函数是memcache_add()。
 
参数：
$key ：将要存储的键值。
$var ：存储的值，字符型和整型会按原值保存，其他类型自动序列化以后保存。
$flag：是否用MEMCACHE_COMPRESSED 来压缩存储的值， true 表示压缩， false 表示不压缩。
$expire：存储值的过期时间，如果为0表示不会过期，你可以用unix时间戳或者描述来表示从现在开始的时间，但是你在使用秒数表示的时候，不要超过2592000秒 (表示30天)。
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。如果$key值已经存在，则会返回FALSE。 其他情况下Memcache::add()的用法类似于Memcache::set()。
 
例子：
<?php
$memcache_obj = memcache_connect("localhost", 11211);
/* 面向过程API */memcache_add($memcache_obj, 'var_key', 'test variable', false, 30);
/* 面向对象API */$memcache_obj->add('var_key', 'test variable', false, 30);
?>
 
Memcache::addServer 用法
bool Memcache::addServer ( string $host [, int $port [, bool $persistent [, int $weight [, int $timeout [, int$retry_interval [, bool $status [, callback $failure_callback ]]]]]]] )
说明：
添加一个可供使用的服务器地址到连接池中，连接用Memcache::addServer打开，脚本执行完后自动关闭，或者可以用Memcache::close()手动关闭。相同函数是memcache_add_server()。
当用这个方法的时候（相对于Memcache::connect()和 Memcache::pconnect()方法），网络连接只有等需要的时候才会建立，因此不会因为增加很多的服务器到连接池而增加系统负担，因为很多服务器可能没有使用。
故障恢复会发生在这个方法执行的任何阶段，只要其他的服务器是正常的，这些连接请求的失败用户不会注意到。任何一种socket或者memcached服务器级的错误可以触发故障恢复。正常的客户端错误比如增加一个存在的键值不会引发故障恢复。
 
参数：
$host服务器的地址
$port服务器端口
$persistent是否是一个持久连接
$weight这台服务器在所有服务器中所占的权重
$timeout连接的持续时间
$retry_interval连接重试的间隔时间，默认为15,设置为-1表示不进行重试
$status控制服务器的在线状态
$failure_callback允许设置一个回掉函数来处理错误信息。
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。
 
例子：
<?php
/* 面向对象API */
$memcache = new Memcache;$memcache->addServer('memcache_host', 11211);$memcache->addServer('memcache_host2', 11211);
/* 面向过程 API */
$memcache_obj = memcache_connect('memcache_host', 11211);memcache_add_server($memcache_obj, 'memcache_host2', 11211);
?>
 
 
Memcache::close 用法
bool Memcache::close ( void )
说明：
关闭memcache服务器连接。这个函数不会关闭长连接，长连接只有在web服务器关闭或者重启的时候才会关闭。相同的函数memcache_close()
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。
 
例子：
<?php
/* 面向过程 API */$memcache_obj = memcache_connect('memcache_host', 11211);/* 
执行一些代码..*/memcache_close($memcache_obj);
/* 面向对象 API */$memcache_obj = new Memcache;$memcache_obj->connect('memcache_host', 11211);/* 执行一些代码..*/$memcache_obj->close();
?>
 
 
Memcache::connect 用法
bool Memcache::connect ( string $host [, int $port [, int $timeout ]] )
 
说明：
打开memcached服务器连接，建立一个到memcached服务器的连接，用Memcache::connect打开的连接会在脚本执行完毕后自动关闭。你也可以用Memcache::close()去关闭连接。相同的函数是memcache_connect()。
 
参数：
$host：指向memcached正在收听的链接的主机，这个参数会有另一种特殊的连接方式unix:///path/to/memcached.sock，即用unix的域名sockets，这种情况下，端口必须设置为0
$port：指向memcached正在收听的链接的端口，用unix的域名sockets的情况下，端口必须设置为0
$timeout：用于连接守护进程的秒数，当你改变默认的1秒的值的时候，你需要考虑一下，如果你的连接太慢的话，你可能会失去缓存的优势。
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。
 
例子：
<?php
/* 面向过程 API */
$memcache_obj = memcache_connect('memcache_host', 11211);
/* 面向对象 API */
$memcache = new Memcache;$memcache->connect('memcache_host', 11211);
?>
memcache::debug
bool memcache_debug ( bool $on_off )
 
说明：
控制调试功能，前提是php在编译的时候使用了-enable-debug选项，否则这个函数不会有作用。
 
参数：
$on_off：true表示开启调试，false表示关闭调试
 
返回值：
如果php在编译的时候使用了-enable-debug选项，返回true，否则返回false
 
 
Memcache::decrement 用法
int Memcache::decrement ( string $key [, int $value ] )
 
说明：
Memcache::decremen方法的作用是对保存的某个key中的值进行减法操作，用法跟Memcache::increment类似。
你也可以用memcache_decrement()函数。
 
参数：
Key:想要减少的键的名字
Value:想要减少的值。
 
返回值：
如果成功，返回被减少后的值，如果失败返回false。
 
例子：
<?php
$memcache = new Memcache;
$memcache->connect('localhost', 11211);
$memcache->set('test_item', 8);
$memcache->increment('test_item', 4);
echo $memcache->decrement('test_item', 7);
// 显示 5
?>
这个例子连Memcache::increment函数都一块演示了。
 
Memcache::delete 用法
bool Memcache::delete ( string $key [, int $timeout ] )
 
说明：
删除一个key值，如果参数$timeout被设置，那么存储的值会在设置的秒数以后过期，你也可以用函数memcache_delete()
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。
 
例子：
<?php
/* 面向过程 API */$memcache_obj = memcache_connect('memcache_host', 11211);
/* 在10秒以后，缓存的值会被服务器删除 */memcache_delete($memcache_obj, 'key_to_delete', 10);
/* 面向对象 API */$memcache_obj = new Memcache;$memcache_obj->connect('memcache_host', 11211);
$memcache_obj->delete('key_to_delete', 10);
?>
 
 
Memcache::flush
bool Memcache::flush ( void )
 
说明：
清除所有缓存的数据。Memcache::flush实际上没有释放资源，它仅仅将所有的缓存标记为过期，这样可以使新的缓存来覆盖被占的内存空间。一样的函数是memcache_flush()
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。
 
例子：
<?php
/* 面向过程 API */$memcache_obj = memcache_connect('memcache_host', 11211);
memcache_flush($memcache_obj);
/* 面向对象 API */
$memcache_obj = new Memcache;$memcache_obj->connect('memcache_host', 11211);
$memcache_obj->flush();
?>
 
 
Memcache::get
string Memcache::get ( string $key [, int &$flags ] )
array Memcache::get ( array $keys [, array &$flags ] )
 
说明：
方法的作用是获取一个key值，key值可以是一个数组，结果会包含键值对。
 
参数：
$key是键值或者一个键的数组值。
$flags如果这个参数存在，那么$flags跟写入这个参数的值相关，这些$flags 类似于Memcache::set()函数里的$flags。
 
返回值：
如果成功，则返回key对应的值，如果失败则返回false.
 
例子：
<?php
/* 面向过程 API */$memcache_obj = memcache_connect('memcache_host', 11211);$var = memcache_get($memcache_obj, 'some_key');
/* 面向对象 API */$memcache_obj = new Memcache;$memcache_obj->connect('memcache_host', 11211);$var = $memcache_obj->get('some_key');
/* 你可以使用数组键作为参数，如果值没有在服务器中找到，那么结果数组不会包含该键*/
/* 面向过程 API */$memcache_obj = memcache_connect('memcache_host', 11211);$var = memcache_get($memcache_obj, Array('some_key', 'another_key'));
/* 面向对象 API */$memcache_obj = new Memcache;$memcache_obj->connect('memcache_host', 11211);$var = $memcache_obj->get(Array('some_key', 'second_key'));
?>
 
Memcache::getExtendedStats
array Memcache::getExtendedStats ([ string $type [, int $slabid [, int $limit ]]] )
 
说明：
获取进程池中所有进程的运行系统统计。相同函数是memcache_get_extended_stats()
 
参数：
$type表示要求返回的类型：reset, malloc, maps, cachedump, slabs, items, sizes;
$slabid第一个参数设置为"cachedump"时使用的。
$limit第一个参数设置为"cachedump"时使用的。
 
返回值：
如果成功，返回统计信息，失败会返回false
 
例子：
<?php    $memcache_obj = new Memcache;    $memcache_obj->addServer('memcache_host', 11211);    $memcache_obj->addServer('failed_host', 11211);        $stats = $memcache_obj->getExtendedStats();
   //slabs机制分配管理内存的情况
$statsslab = $memcache_obj->getExtendedStats(slabs);    ?>
 
 
Memcache::getServerStatus
int Memcache::getServerStatus ( string $host [, int $port ] )
 
说明：
获取运行服务器的参数。返回一个服务器在线或者离线的状态。相同的函数是memcache_get_server_status()
 
参数：
$host：正在收听的连接的主机
$port正在收听的连接的主机的端口，默认是11211
 
返回值：
成功返回服务器状态，服务器没有启动会返回0，其他数字的时候表示服务器是启动状态的。
 
例子：
<?php
/* 面向对象 API */$memcache = new Memcache;$memcache->addServer('memcache_host', 11211);echo $memcache->getServerStatus('memcache_host', 11211);
/* 面向过程 API */$memcache = memcache_connect('memcache_host', 11211);echo memcache_get_server_status($memcache, 'memcache_host', 11211);
?>
 
 
Memcache::getStats
array Memcache::getStats ([ string $type [, int $slabid [, int $limit ]]] )
 
说明：
返回服务器的一些运行统计信息。相同的函数是memcache_get_stats()
 
参数：
$type表示要求返回的类型：reset, malloc, maps, cachedump, slabs, items, sizes;
$slabid第一个参数设置为"cachedump"时使用的。
$limit第一个参数设置为"cachedump"时使用的。
 
返回值：
成功返回服务器的统计信息数组，失败返回false。
Memcache::getVersion
string Memcache::getVersion ( void )
 
说明：
返回运行的Memcache的版本信息。相同函数memcache_get_version()
 
返回值：
成功返回服务器的版本信息，失败的时候返回false。
 
例子：
<?php
/* 面向对象 API */$memcache = new Memcache;$memcache->connect('memcache_host', 11211);echo $memcache->getVersion();
/* 面向过程 API */$memcache = memcache_connect('memcache_host', 11211);echo memcache_get_version($memcache);
?>
 
 
Memcache::increment
int Memcache::increment ( string $key [, int $value ] )
对保存的某个key中的值进行加法操作
用法参考Memcache::decrement
 
 
Memcache::pconnect
bool Memcache::pconnect ( string $host [, int $port [, int $timeout ]] )
说明：
创建一个Memcache的持久连接对象
用法与Memcache::connect()相似，不同点地方是Memcache::pconnect是建立的持久连接。这个连接在脚本执行完或者Memcache::close()函数运行也不会被关闭。与它相同的函数是 memcache_pconnect()
 
参数：
$host：指向memcached正在收听的链接的主机，这个参数会有另一种特殊的连接方式unix:///path/to/memcached.sock，即用unix的域名sockets，这种情况下，端口必须设置为0
$port：指向memcached正在收听的链接的端口，用unix的域名sockets的情况下，端口必须设置为0
$timeout：用于连接守护进程的秒数，当你改变默认的1秒的值的时候，你需要考虑一下，如果你的连接太慢的话，你可能会失去缓存的优势。
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE
<?php
/* 面向过程 API */$memcache_obj = memcache_pconnect('memcache_host', 11211);
/* 面向对象 API */
$memcache_obj = new Memcache;$memcache_obj->pconnect('memcache_host', 11211);
?>
 
 
Memcache::replace
bool Memcache::replace ( string $key , mixed $var [, int $flag [, int $expire ]] )
说明：
对一个已有的key进行覆写操作。相同函数是memcache_replace()
 
参数：
$key ：将要存储的键值。
$var ：存储的值，字符型和整型会按原值保存，其他类型自动序列化以后保存。
$flag：是否用MEMCACHE_COMPRESSED 来压缩存储的值， true 表示压缩， false 表示不压缩。
$expire：存储值的过期时间，如果为0表示不会过期，你可以用unix时间戳或者描述来表示从现在开始的时间，但是你在使用秒数表示的时候，不要超过2592000秒 (表示30天)。
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。如果$key值已经存在，则会返回FALSE。
 
<?php
$memcache_obj = memcache_connect('memcache_host', 11211);
/* 面向过程 API */memcache_replace($memcache_obj, "test_key", "some variable", false, 30);
/* 面向对象 API */$memcache_obj->replace("test_key", "some variable", false, 30);
?>
 
 
Memcache::set
bool Memcache::set ( string $key , mixed $var [, int $flag [, int $expire ]] )
说明：
添加一个值，如果已经存在，则覆写。相同函数是memcache_set()
 
参数：
$key ：将要存储的键值。
$var ：存储的值，字符型和整型会按原值保存，其他类型自动序列化以后保存。
$flag：是否用MEMCACHE_COMPRESSED 来压缩存储的值， true 表示压缩， false 表示不压缩。
$expire：存储值的过期时间，如果为0表示不会过期，你可以用unix时间戳或者描述来表示从现在开始的时间，但是你在使用秒数表示的时候，不要超过2592000秒 (表示30天)。
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。
 
例子：
 
/*  面向对象  API */
$memcache_obj  = new  Memcache ;
/*  连接到 memcached 服务器  */ $memcache_obj -> connect ( 'memcache_host' ,  11211 );
/* 给键 'var_key' 设置值 ,  使用压缩方式，延时是 50 秒 */ $memcache_obj -> set ( 'var_key' ,  'some really big variable' ,  MEMCACHE_COMPRESSED ,  50);
echo  $memcache_obj -> get ( 'var_key' );
 
Memcache::setCompressThreshold
 
bool Memcache::setCompressThreshold ( int $threshold [, float $min_savings ] )
说明：
对大于某一大小的数据进行压缩。相同的函数是memcache_set_compress_threshold()
 
参数：
setCompressThreshold方法有两个参数，第一个参数表示处理数据大小的临界点，第二个参数表示压缩的比例，默认为0.2。
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。
 
例子：
<?php
/* 面向对象 API */
$memcache_obj = new Memcache;$memcache_obj->addServer('memcache_host', 11211);$memcache_obj->setCompressThreshold(20000, 0.2);
/* 面向过程 API */
$memcache_obj = memcache_connect('memcache_host', 11211);memcache_set_compress_threshold($memcache_obj, 20000, 0.2);
?>
 
 
Memcache::setServerParams         
bool Memcache::setServerParams ( string $host [, int $port [, int $timeout [, int $retry_interval [, bool $status[, callback $failure_callback ]]]]] )
说明：
在运行时修改服务器的参数。相同函数是memcache_set_server_params()。
 
参数：
$host服务器的地址
$port服务器端口
$timeout连接的持续时间
$retry_interval连接重试的间隔时间，默认为15,设置为-1表示不进行重试
$status控制服务器的在线状态
$failure_callback允许设置一个回掉函数来处理错误信息。
 
返回值：
如果成功则返回 TRUE，失败则返回 FALSE。
 
例子：
<?php
function _callback_memcache_failure($host, $port) {    print "memcache '$host:$port' failed";}
/* 面向对象 API */
$memcache = new Memcache;
// 离线模式增加一个服务器$memcache->addServer('memcache_host', 11211, false, 1, 1, -1, false);
// 把服务器设成在线$memcache->setServerParams('memcache_host', 11211, 1, 15, true, '_callback_memcache_failure');
/* 面向过程 API */
$memcache_obj = memcache_connect('memcache_host', 11211);memcache_set_server_params($memcache_obj, 'memcache_host', 11211, 1, 15, true, '_callback_memcache_failure');
?>
 

