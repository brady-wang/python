第二部分 Mongodb增删改查
学习内容:1.mongodb增加操作2.mongodb删除操作3.mongodb查询操作增删改查的高级应用Capped Collection(固定集合)GridFS 大文件上传或下载
1: insertMongoDB是面向文档存储的数据库，文档结构形式叫BSON(类似JSON)db.c1.insert({name:"user1"});db.c1.save({_id:1, name:"user1"}); //save()如果已经存在就不会插入，如果不存在就插入//这里要与id相同的值才不会被插入//save就是id相同就更新，没有相同id就插入
删除db.c1.remove();db.c1.remove({name:"user1"});
db.c1.find({name:"user1"},{name:1, age:1, _id:0});条件表达式< <= > >= !=$gt: 大于$lt: 小于$gte: 大于等于$lte: 小于等于$ne: 不等于
统计: db.c1.count();db.c1.find().count();//count(1); 里面有一个条件，如果为1,那么会取条件，如果为0不会理会条件语句
排序:db.c1.find().sort(age:1); //1是升序 0是降序
取多少个db.c1.find().limit(4);
跳过几个db.c1.skip(1);db.c1.skip(0).limit(10).sort({age:-1});
$all操作类似于$in操作，但是不同的是，$all操作要求数组里面的值全部是包含在返回的记录里面db.c2.find({post:{$all:[1,2,3]}});
$exists操作检查一个字段是否存在db.c2.find({age:{$exists:1}}); 测试一个字段是否存在
$mod操作可以让我们简单的进行取模操作，而不需要用到where子句//这里的是字段值的取余操作db.c1.find({age:{$mod:[2]}});
$in 操作类似于传统关系数据库中的INdb.c1.find({age:{$in:[1,2,3]}})
$nin 与$in相反db.c1.find({age:{$nin:[2,3,4]}});
$or 查看指定多个条件的记录，跟sql的or差不多db.c1.find({$or:[{name:"user1"},{name:"user2"},{age:10}]});
$nor 与$or相反过滤指定的条件db.c1.find({$nor:[{name:"user1"},{name:"user2"},{age:10}]});
 
学习内容:1.mongodb增加操作2.mongodb删除操作3.mongodb查询操作增删改查的高级应用Capped Collection(固定集合)GridFS 大文件上传或下载
1: insertMongoDB是面向文档存储的数据库，文档结构形式叫BSON(类似JSON)db.c1.insert({name:"user1"});db.c1.save({_id:1, name:"user1"}); //save()如果已经存在就不会插入，如果不存在就插入//这里要与id相同的值才不会被插入//save就是id相同就更新，没有相同id就插入
删除db.c1.remove();db.c1.remove({name:"user1"});
db.c1.find({name:"user1"},{name:1, age:1, _id:0});条件表达式< <= > >= !=$gt: 大于$lt: 小于$gte: 大于等于$lte: 小于等于$ne: 不等于
统计: db.c1.count();db.c1.find().count();//count(1); 里面有一个条件，如果为1,那么会取条件，如果为0不会理会条件语句
排序:db.c1.find().sort(age:1); //1是升序 0是降序
取多少个db.c1.find().limit(4);
跳过几个db.c1.skip(1);db.c1.skip(0).limit(10).sort({age:-1});
$all操作类似于$in操作，但是不同的是，$all操作要求数组里面的值全部是包含在返回的记录里面db.c2.find({post:{$all:[1,2,3]}});
$exists操作检查一个字段是否存在db.c2.find({age:{$exists:1}}); 测试一个字段是否存在
$mod操作可以让我们简单的进行取模操作，而不需要用到where子句//这里的是字段值的取余操作db.c1.find({age:{$mod:[2]}});
$in 操作类似于传统关系数据库中的INdb.c1.find({age:{$in:[1,2,3]}})
$nin 与$in相反db.c1.find({age:{$nin:[2,3,4]}});
$or 查看指定多个条件的记录，跟sql的or差不多db.c1.find({$or:[{name:"user1"},{name:"user2"},{age:10}]});
$nor 与$or相反过滤指定的条件db.c1.find({$nor:[{name:"user1"},{name:"user2"},{age:10}]});
$size操作将会查询数组长度等于输入参数的数组
$elemMatch 元素配置的意思
slaveOk当我们在replica set进行检索操作时，默认的路由会选择master机器，当我们需要针对任意的从机进行查询的时候，我们需要开启slaveOk选项。当我们在没有开启salveOk选项的时候，如果进行此操作会报如下错： *** not master and slaveok=false所以我们要进行如下操作： rs.slaveOk(); // enable querying a secondary db.users.find(...)
11) Cursors游标及Cursor Methods遍历游标var x = db.c1.find();x.next();x.hasNext();while(x.hasNext() == true){x.next();}
NULL查询(有一个值是为null,或者一个值不存在)db.c4.find({age:null}); //列出所有为null或者不存在的值db.c4.find({age:{$type:10}}); //列出所有为null的数据
第二种写法db.c4.find({age:{$exists:1, $in:[null]}});//两个条件，一个是exists必须存在，二是为null的数据
$slice
4. Update1) 语法 db.collection.update( criteria, objNew, upsert, multi )参数说明： Criteria：用于设置查询条件的对象 Objnew：用于设置更新内容的对象 Upsert：如果记录已经存在，更新它，否则新增一个记录 Multi：如果有多个符合条件的记录，全部更新 注意：默认情况下，只会更新第一个符合条件的记录
$set //修改字段 db.c5.update({name:"user1"},{$set:{age:10}},0,1);
$inc //对字段进行加 a = a+1db.c5.update({},{$inc:{age:-10}},0,1);
$unset //删除一个字段db.c5.update({},{$unset:{age:1}});
$pushdb.c5.update({},{$push:{arr:1}}); //压入一个值进入数组
$pushAlldb.c5.update({}, {$pushAll:{arr:[2,3,4]}}); //压入多个值进入数组
$popdb.c5.update({}, {$pop:{arr:1}}); //弹出数组中的最后一个元素db.c5.update({}, {$pop:{arr:1}}); //弹出数组中的第一个元素
$addToSet语句: {$addToSet: {field: value}}如果filed是一个已经存在的数组，并且value值不在其中，那么value加入到数组中filed不存在，那么把value当成一个数组存储到filed中filed是一个已经存在的非数组类型，那么将会报错
扩展肜户{$addToSet:{a:{$each:[1,2,3,4,5,6]}}};
$pull语法:{$pull:{field:_value}}功能: 如果field是一个数组，那么删除符合_value检索条件的记录如果field是一个已经存在的非数组，那么会报错
$pullAll语法: {$pullAll:{field:value_array}}功能: 同$pull类似，只是value的数据类型是一个数组
$rename语法:{$rename:{old_field_name: new_field_name}}功能:重命名指定的字段名称
特殊操作符:$$操作符代码查询记录中第一个匹配条件的记录项$db.c5.update({"arr.title":"linx"}, {$set:{arr.$.title:"I lover linx"}});
注意: 在数组中用$配合$unset操作符的时候，效果不是删除的元素，而是把匹配的元素变成null$db.c5.update({"arr.title":"php"},{$unset:{arr.$:1}});
var x = db.c1.findOne({"user":"user1"});x.age = 40;x.nickname="xlc";db.c1.save(x);
性能监控通过对数据库的性能监控，能够更好的了解数据库的工作状态，从页进行优化介绍几个性能监控的工具Mongofniff此工具可以从底层监控到底有那些命讼发送给MongoDB去执行./mongosniff --soruce NET lo它是实时动态监视的，需要打开中一个客户端进行命讼操作，可以将这些数据输出到一个日志文件中，那么就可以保留下所有数据库操作的历史记录，对于后期的性能分析和安全审计工作将是一个巨大的贡献
