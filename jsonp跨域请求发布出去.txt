jsonp跨域请求发布出去
　　最近在做运动城项目，这一个项目下面有多个子项目，如主数据项目，pos项目等。主数据项目的域名为www.topmall.com，POS项目的域名为pos.topmall.com。即两个项目的主域名相同，子域名不相同。
　　我们的登陆认证是放在主数据项目的，即进入POS项目如果检测未登陆，是先要调用主数据的一个登陆接口登陆后才可以访问的。这时候跨域问题就出现了，进入POS项目之后跳出登陆框，输入用户名密码请求主数据的http://www.topmall.com/signin进行登陆，看到返回的response里面也有Set-cookie，但是再次请求POS项目的http://pos.topmall.com/pos/cashier/info 资源时却报错了。调试进去看发现后台获取不到当前登陆的用户，查看请求头发现并没有把登陆时返回的cookies设置到第二次请求的头里面。
　　查询资料才知道登陆请求的主数据项目与POS项目不属于同一个子域，即存在跨域，跨域请求想要带上cookies必须在请求头里面加上{crossDomain: true, xhrFields: {withCredentials: true}}设置，于是在index界面加上了如下代码：







1
2
3
4
5



<script>
    $(function () {  //, headers: { 'x-requested-with': 'XMLHttpRequest' }
        $.ajaxSetup({crossDomain: true, xhrFields: {withCredentials: true}});
    });
</script>








　　然后在后台代码返回response时做如下处理：







1
2
3
4
5
6
7
8
9
10
11
12



private boolean recharge(HttpServletRequest request, HttpServletResponse response) throws Exception {
        String url = request.getHeader("Origin");
        logger.debug("Access-Control-Allow-Origin:" + url);
        if (!StringUtils.isEmpty(url)) {
            String val = response.getHeader("Access-Control-Allow-Origin");
            if (StringUtils.isEmpty(val)) {
                response.addHeader("Access-Control-Allow-Origin", url);
                response.addHeader("Access-Control-Allow-Credentials", "true");
            }
        }
        return true;
    }








　　
再次访问，发现请求头已经可以携带cookies。
