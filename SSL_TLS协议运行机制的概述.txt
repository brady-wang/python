SSL/TLS协议运行机制的概述
SSL/TLS协议运行机制的概述
 

作者： 阮一峰
日期： 2014年2月 5日


互联网的通信安全，建立在SSL/TLS协议之上。
本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅RFC文档。

一、作用
不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。

（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。
（2） 篡改风险（tampering）：第三方可以修改通信内容。
（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

SSL/TLS协议是为了解决这三大风险而设计的，希望达到：

（1） 所有信息都是加密传播，第三方无法窃听。
（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。
（3） 配备身份证书，防止身份被冒充。

互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。
二、历史
互联网加密通信协议的历史，几乎与互联网一样长。

1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
1996年，SSL 3.0版问世，得到大规模应用。
1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。
2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。

目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。
TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。
三、基本的运行过程
SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
但是，这里有两个问题。
（1）如何保证公钥不被篡改？

解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

（2）公钥加密计算量太大，如何减少耗用的时间？

解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

因此，SSL/TLS协议的基本过程是这样的：

（1） 客户端向服务器端索要并验证公钥。
（2） 双方协商生成"对话密钥"。
（3） 双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。
四、握手阶段的详细过程

"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。
4.1 客户端发出请求（ClientHello）
首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
在这一步，客户端主要向服务器提供以下信息。

（1） 支持的协议版本，比如TLS 1.0版。
（2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。
（3） 支持的加密方法，比如RSA公钥加密。
（4） 支持的压缩方法。

这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。
对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。
4.2 服务器回应（SeverHello）
服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。

（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
（2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。
（3） 确认使用的加密方法，比如RSA公钥加密。
（4） 服务器证书。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。
4.3 客户端回应
客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。

（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。
（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。
至于为什么一定要用三个随机数，来生成"会话密钥"，dog250解释得很好：

"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。
4.4 服务器的最后回应
服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。

（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。

五、参考链接

MicroSoft TechNet, SSL/TLS in Detail
Jeff Moser, The First Few Milliseconds of an HTTPS Connection
Wikipedia, Transport Layer Security
StackExchange, How does SSL work?

（完）


文档信息

版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
发表日期： 2014年2月 5日
更多内容： 档案 » 开发者手册
购买文集： 《如何变得有思想》
社交媒体： twitter， weibo
Feed订阅： 







相关文章

2016.03.08: Systemd 入门教程：实战篇
上一篇文章，我介绍了 Systemd 的主要命令，今天介绍如何使用它完成一些基本的任务。

2016.03.07: Systemd 入门教程：命令篇
Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。

2016.02.28: Linux 守护进程的启动方法
"守护进程"（daemon）就是一直在后台运行的进程（daemon）。

2016.01.06: Commit message 和 Change log 编写指南
Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。




广告（购买广告位）






留言（63条）





west 说：



好文。全面而易懂



2014年2月 5日 20:09 | # | 引用








李狗蛋 说：



坏蛋总不放过任何一丝做恶的机会,太多不要脸的运营商在链路劫持强插广告,直接修改用户的HTTP数据包,再就是NSA之流肆无忌惮的窃听
发现一个HTTPS有意思的地方,只要53端口数据被转发,不管域名对应的DNS解析IP是不是域名真实IP,只要最后都是53端口转发到真实IP之上,就不会弹HTTPS证书错误
比如 https://a.com 对应 ipa 不通
那么劫持DNS解析 https://a.com 到 ipb上 (ipb是通的)
只要在ipb上设置 ipb:53转发到 ipa:53
这样访问 https://a.com 就通了,而且没证书错误



2014年2月 5日 20:10 | # | 引用








Niclau 说：



启用Server Name Indication扩展后，第一步客户端发送请求，同时明文发送域名到server?



2014年2月 6日 11:32 | # | 引用








古明地恋 说：



您好，我有一个疑问。第一步是用服务器公钥加密的。而服务器公钥包含在证书中。但是如果入侵者获取到服务器证书，并用于解密之后的key，再用key来解密通信内容，这样怎么防范？



2014年2月 6日 15:57 | # | 引用








Barret Lee 说：



阮老师写的文章都是鞭辟入里啊，一般是站在那些角度去阐述一个观点或者描述一个事物呢？



2014年2月 6日 23:38 | # | 引用








harchiko 说：



Smart !智慧的发明!!



2014年2月 7日 22:21 | # | 引用








魂魄妖梦 说：




引用古明地恋的发言：
您好，我有一个疑问。第一步是用服务器公钥加密的。而服务器公钥包含在证书中。但是如果入侵者获取到服务器证书，并用于解密之后的key，再用key来解密通信内容，这样怎么防范？

服务器证书只包含公钥，无法解密key。解密需要用私钥。
私钥一般放在server端。如果能拿到私钥，基本上可以肯定被入侵了。这时候获取私钥都不算个事了你说是不。



2014年2月 8日 00:10 | # | 引用








lucas 说：



阮兄的文章非常值得一读，简洁又能把事情的来龙去脉讲的清清楚楚的，不简单。



2014年2月 8日 09:47 | # | 引用








CJey 说：




引用Niclau的发言：
启用Server Name Indication扩展后，第一步客户端发送请求，同时明文发送域名到server?

对的, 确实是明文, 否则服务端无法确定向客户端推送哪张证书而且, 也没法使用密文, 因为密钥尚未协商好再者, 使用密文也没有意义, 篡改域名只能影响服务端返回的证书, 而所有的证书本来就都是公开的



2014年2月 9日 11:41 | # | 引用








CJey 说：



@李狗蛋：
不太能理解你想表达的意思不过, SSL/TLS协议并不关心双方的IP, DNS劫持是无法攻击SSL/TLS的所以, 我觉得你的这个测试结果另有原因



2014年2月 9日 11:53 | # | 引用








onion 说：



其实，看阮兄的博客主要目的就是学习阮兄的总结与再表达能力，对于这篇来说，真的不懂，但是感觉看得很舒服，层次清晰，用语准确，赞！



2014年2月10日 11:43 | # | 引用








masstensor 说：



文章写的浅显易懂，看了很有收获。不过，需要说明的是，使用PKI机制进行密钥交换只是TLS规范的一种实现形式，还有其他的形式可以用于密钥交换，比如SRP和PSK协议。



2014年2月11日 10:19 | # | 引用








twd2 说：




引用CJey的发言：
 
对的, 确实是明文, 否则服务端无法确定向客户端推送哪张证书而且, 也没法使用密文, 因为密钥尚未协商好再者, 使用密文也没有意义, 篡改域名只能影响服务端返回的证书, 而所有的证书本来就都是公开的

如果有中间人通过判断域名，来决定是否阻断连接怎么办呢



2014年2月13日 00:30 | # | 引用








nuooo 说：



请考虑介绍下常用于SPDY的HTTPS falst start握手，它比标准的握手少一个“server finished"的步骤



2014年2月16日 03:13 | # | 引用








sunny 说：



好文章。



2014年2月23日 11:35 | # | 引用








点虎 说：



感谢！没有微信公众号？



2014年2月24日 10:35 | # | 引用








hyh 说：



文中的 SeverHello 是不是应该是 ServerHello?



2014年2月27日 20:54 | # | 引用








GlacJAY 说：



只有第一次的握手过程是明文的，之后的自动重协商通信是用上一次的密钥来加密的。



2014年3月 1日 13:19 | # | 引用








yd 说：



您好，我有一个疑问。
第一步，服务器端的响应内容包含证明服务器自身的证书，客户端得到证书后进行有效性验证，请问客户端是如何进行验证的？根据哪些信息验证的？



2014年3月11日 15:43 | # | 引用








dcb110 说：



查了好多文章，终于在这里把整个握手流程以及中间一些疑问搞清楚了，现在再去看那些代码，清楚了很多，感谢博主。



2014年3月13日 13:45 | # | 引用








Bravluna 说：




引用yd的发言：
您好，我有一个疑问。
第一步，服务器端的响应内容包含证明服务器自身的证书，客户端得到证书后进行有效性验证，请问客户端是如何进行验证的？根据哪些信息验证的？

证书里是服务器的公钥和身份信息，这些是经过证书颁发机构即CA公证过的，客户端拿到后去CA验证，看这个公钥是不是服务器的，若不是说明证书是伪造的，当然如果证书经过数字签名证书就不可能被伪造了



2014年4月30日 23:29 | # | 引用








ZeroLing 说：



来支持一下阮老师写的东西



2014年5月24日 16:47 | # | 引用








Charles 说：



看来说清楚这个东西，还是太过难了一点，这个文章也太过概述了，感觉很多关键点没有说清楚啊，看得我好累。不过还是感谢阮老师，已经让我省了不少时间了。



2014年5月29日 23:12 | # | 引用








heliar 说：




引用yd的发言：
您好，我有一个疑问。
第一步，服务器端的响应内容包含证明服务器自身的证书，客户端得到证书后进行有效性验证，请问客户端是如何进行验证的？根据哪些信息验证的？

这里还有一个信任链的问题，一般都是有一家第三方的根证书签名机构办法证书，我们相信这个第三方机构，从而相信它颁发的证书，当然也有根证书授权下一层的证书颁发机构，然后由这个机构给网站服务器做验证的情况



2014年7月19日 02:29 | # | 引用








Pingia 说：



我感觉4。3部分 的（1）步和（2）(3)两步中间还有些步骤可以注明清楚点。事实上服务端和客户端在拥有pms后计算出来的密钥并不是会话密钥，而是一个中间密钥，最终的会话密钥是通过这个中间密钥计算出来的。至于这个计算方法，我也不清楚是什么？有知道的朋友望告知。
还有这一部分最后一句：此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。
我感觉客户端发送证书应该是在这一步骤之前。



2014年8月23日 13:31 | # | 引用








王正一 说：



通俗易懂，太赞了



2014年9月15日 14:26 | # | 引用








freenet 说：



讲得非常好！学习了...



2014年10月 2日 16:58 | # | 引用








ikong 说：



需要注意的是，"握手阶段"的所有通信都是明文的。
这句话不对吧？pre master key应该是客户端用服务端公钥加密之后再发送给服务端的，这不能算明文吧？


2014年10月 9日 02:56 | # | 引用








兴杰 说：



提问一下，握手的第3步，pre-master key 如果被拦截，是否可以被伪造或篡改？ 因为只使用服务器的公钥加密。



2014年10月14日 12:09 | # | 引用








feix 说：



关于 至于为什么一定要用三个随机数，来生成"会话密钥" 这个地方，其实还有一点：pre-master key 用服务器的公钥加密，可以防止第三方冒充服务器，因为任何人都可以获取已经公开的服务器公钥与客户段进行通信。想要获得 pre-master key 明文只有利用服务器的私钥进行解密，所以这里进行了服务器的身份验证，也防止了中间人攻击。
另外，当服务器需要验证客户端时，客户端在发送 pre-master key 之前需要发送客户端公钥到服务器，可以选择对 pre-master key 用客户端的私钥签名然后再用服务器公钥加密，则服务器收到 pre-master key 同时对客户端进行了身份验证。



2014年10月16日 01:27 | # | 引用








中国证书CHINASSL 说：



好文章，通俗易懂的介绍SSL，本文将引用的中国证书CHINASSL博客，谢谢



2014年10月21日 10:38 | # | 引用








lp 说：



有个问题，握手时是明文通信，那就会被截获到公钥、三个随机数，这样对话密钥不久可以知道了？那后面的对话加密不就会被解密？



2014年12月20日 01:41 | # | 引用








goodboy1983 说：



如果有个proxy, 先和客户端建立连接（不下发服务器证书，也不要求客户端上报证书），再和SP建立连接。 对服务器下发的证书默认接受。 相当于 CLIENT-PROXY之间是互相不认证证书，PROXY-WEB SERVER之间是验证服务器证书。 是否有安全隐患？



2014年12月20日 03:02 | # | 引用








nowlater 说：



@goodboy1983: 应该不会有安全隐患吧，pre-master key是用服务器端公钥加密的，client-proxy无法解密，不能获取到pre-master key。在安全要求更高的金融领域，服务器端会认证客户端，比如银行会给客户发u盾。这就更安全了。



2014年12月26日 11:54 | # | 引用








哈哈 说：



服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。 这个会话密钥怎么计算的呢？



2015年1月13日 19:57 | # | 引用








youyingyang 说：



阮一峰同志是一座宝库4年之前就开始看您的博客，但是基本只看人文社科类和科普性质的，视野很开阔，写的很棒。最近随着自己的兴趣变化，开始学习编程，没想到搜“RESTful架构”，第一篇文章就是您的，写的太好了，明白如水！高手有很多，但是乐意长时间坚持分享，而且做科普做的这么好的高手太少了！感谢！



2015年1月15日 15:43 | # | 引用








hilojack 说：




引用CJey的发言：
 
对的, 确实是明文, 否则服务端无法确定向客户端推送哪张证书而且, 也没法使用密文, 因为密钥尚未协商好再者, 使用密文也没有意义, 篡改域名只能影响服务端返回的证书, 而所有的证书本来就都是公开的

将域名加密还是有意义的，比如GFW 或者 Hacker 等想知道你请求了哪些网站，酱紫



2015年3月23日 23:57 | # | 引用








hilojack 说：



关于TLS/SSL 四次握手的一个疑问。在协商会话密钥的阶段：客户端的请求是用服务端的公钥加密的，第三方截获后是没有办法解密的；服务端返回的请求是用服务端的私钥加密的，第三方截获后可以通过公钥解密的。
这引发我的疑问，在最后第4步，服务端返回的会话密钥(Session Key) 是用服务端的私钥加密的，那第三方不就可以解密出这个Session Key 吗？有了这个Session Key 后不就可以破译出通信数据吗？



2015年3月24日 12:01 | # | 引用








Zhaodawei 说：




引用hilojack的发言：
关于TLS/SSL 四次握手的一个疑问。在协商会话密钥的阶段：客户端的请求是用服务端的公钥加密的，第三方截获后是没有办法解密的；服务端返回的请求是用服务端的私钥加密的，第三方截获后可以通过公钥解密的。
这引发我的疑问，在最后第4步，服务端返回的会话密钥(Session Key) 是用服务端的私钥加密的，那第三方不就可以解密出这个Session Key 吗？有了这个Session Key 后不就可以破译出通信数据吗？

第四步服务器不会返回会话密钥！！！会话密钥是客户端和服务端各自通过三个随机数和一个密钥导出器最终导出的



2015年4月22日 16:06 | # | 引用








zhaodawei 说：



文中说“三个随机数通过一个密钥导出器最终导出一个对称密钥”，密钥导出器是什么？服务的公钥吗？



2015年4月22日 16:54 | # | 引用








zhaodawei 说：




引用lp的发言：
有个问题，握手时是明文通信，那就会被截获到公钥、三个随机数，这样对话密钥不久可以知道了？那后面的对话加密不就会被解密？

第三个随机数是公钥加密的，只有服务的私钥才能解密。


2015年4月22日 19:23 | # | 引用








shun.aaron 说：



请教一个问题：如果网络中有一台设备，这个设备具有了https服务器的证书和私钥，是不是意味着：这个设备能够通过服务器的私钥来计算出第三个随机数，然后根据相关算法来计算出服务器和client之间的通信秘钥？这样就代表了服务器和client之间的通信内容不在是私密性的了？



2015年5月 9日 13:58 | # | 引用








passerbywhu 说：




引用shun.aaron的发言：
请教一个问题：如果网络中有一台设备，这个设备具有了https服务器的证书和私钥，是不是意味着：这个设备能够通过服务器的私钥来计算出第三个随机数，然后根据相关算法来计算出服务器和client之间的通信秘钥？这样就代表了服务器和client之间的通信内容不在是私密性的了？

HTTPS服务器的私钥你都有了还想怎样。。。-_-



2015年6月25日 11:36 | # | 引用








danieldong 说：



如果key exchange算法是ECDH，那么就不是索要公钥了，也就是说，不采用非对称加密来产生master-key



2015年7月 8日 17:18 | # | 引用








撒啊 说：



请教一下，为什么在session ticket生效的情况下，依然需要交互随机数？ session ticket生效有，已经不用重新生成对称密钥了。



2015年7月21日 23:40 | # | 引用








jedihy 说：



阮老师这篇博客说的不好。前后都有矛盾，有些地方不明确，容易误导。
如果认定握手是完全明文，按阮老师的说法，那中间人直接就可以攻击了，因为他知道所有信息。关键在于随机数的传递这里，会不会用Server的公钥加密。这一点没有强调的话，这篇博客有什么意义，通信安全性的关键在这里。正是用了中间人解不出的信息（需要私钥），所以安全才得到的保障，而并不是因为你用了多少个随机数。不加密的话，你来回发一万次随机数中间人也能够看到。后面的对称密钥通信过程就是扯淡了。



2015年7月27日 09:46 | # | 引用








大山 说：



个人觉得随机数应该最后是这样的结果:3个随机数以某种组合并结合加密算法，客户端和服务器端各自都算出来了动态的私钥和公钥了，这个时候的通信不再是以服务器最早的公钥和私钥为准，而是在两方都知道公钥私钥的情况下通信，服务器端以私钥加密，客户端以公钥解密，客户端以公钥加密，服务器端以私钥解密，至于服务器最原始的公钥和私钥，就是为了保证随机数的安全，不知道这样对不对



2015年8月28日 00:57 | # | 引用








少时诵诗书 说：




引用大山的发言：
个人觉得随机数应该最后是这样的结果:3个随机数以某种组合并结合加密算法，客户端和服务器端各自都算出来了动态的私钥和公钥了，这个时候的通信不再是以服务器最早的公钥和私钥为准，而是在两方都知道公钥私钥的情况下通信，服务器端以私钥加密，客户端以公钥解密，客户端以公钥加密，服务器端以私钥解密，至于服务器最原始的公钥和私钥，就是为了保证随机数的安全，不知道这样对不对

不对，握手完成后就是对称加密，怎么还会有公钥私钥这种非对称加密方法



2015年8月31日 13:06 | # | 引用








小白 说：



大致是看明白了，谁能提供一个pcap包 详细分析下就更加好了。我自己抓了包，都是加密的，看不明白呢



2015年9月 8日 16:30 | # | 引用








YorkYang 说：



一个证书可不可以供两个（不同IP）服务器使用？ 文中讲的 "真实IP" 的校验依据是否为发包的IP？



2015年12月14日 12:01 | # | 引用








gaodi 说：



求助各位大神，现在已知Server端私钥，用wireshark截取握手阶段client和server的random和加密了的pre_master_secret,如何具体解析出https中，http报文内容，最好能有C语言实现的函数和代码，多谢。



2016年1月15日 16:24 | # | 引用








王松 说：




引用onion的发言：
其实，看阮兄的博客主要目的就是学习阮兄的总结与再表达能力，对于这篇来说，真的不懂，但是感觉看得很舒服，层次清晰，用语准确，赞！

赞，突然发现，写技术博客，排版很重要！



2016年1月16日 16:21 | # | 引用








Pingia 说：




引用masstensor的发言：
文章写的浅显易懂，看了很有收获。不过，需要说明的是，使用PKI机制进行密钥交换只是TLS规范的一种实现形式，还有其他的形式可以用于密钥交换，比如SRP和PSK协议。

是这样的，我也想这么一问。



2016年2月21日 12:48 | # | 引用








Pingia 说：




引用兴杰的发言：
提问一下，握手的第3步，pre-master key 如果被拦截，是否可以被伪造或篡改？ 因为只使用服务器的公钥加密。

后面的步骤需要解密这个key，如果被篡改，将不能解密，之后的步骤都不能继续下去了，然后就没有然后了。



2016年2月21日 12:55 | # | 引用








Pingia 说：




引用lp的发言：
有个问题，握手时是明文通信，那就会被截获到公钥、三个随机数，这样对话密钥不久可以知道了？那后面的对话加密不就会被解密？

公钥是公开的，本身就无所谓截获不截获，但是公钥加密的需要配套私钥来解密的。而私钥确是保密的。 第一个随机数是通过公钥加密传输，需要私钥才能解密的，第二个客户端产生的随机数的确是明文传递的，第三个随机数是在服务端本身产生的，并不传输。 有两个随机数参数你无法截获，你怎么计算得到正确的对话密钥？


2016年2月21日 13:03 | # | 引用








Pingia 说：




引用hilojack的发言：
 
将域名加密还是有意义的，比如GFW 或者 Hacker 等想知道你请求了哪些网站，酱紫

个人觉得这个 不在ssl协议要解决的范畴之内。



2016年2月21日 13:07 | # | 引用








Pingia 说：




引用Pingia的发言：
公钥是公开的，本身就无所谓截获不截获，但是公钥加密的需要配套私钥来解密的。而私钥确是保密的。第一个随机数是通过公钥加密传输，需要私钥才能解密的，第二个客户端产生的随机数的确是明文传递的，第三个随机数是在服务端本身产生的，并不传输。有两个随机数参数你无法截获，你怎么计算得到正确的对话密钥？

说错了，第三个也传输给客户端的，只是第一个随机数需要私钥解开，这可以进行防范。



2016年2月21日 13:26 | # | 引用








Pingia 说：




引用zhaodawei的发言：
文中说“三个随机数通过一个密钥导出器最终导出一个对称密钥”，密钥导出器是什么？服务的公钥吗？

我也想问这个，说也没说清楚。


2016年2月21日 13:30 | # | 引用








Pingia 说：




引用YorkYang的发言：
一个证书可不可以供两个（不同IP）服务器使用？ 文中讲的 "真实IP" 的校验依据是否为发包的IP？

可以的，证书只和域名绑定。只要你把这些Ip的服务器绑定到一个域名下就可以。但配置的时候你必须使用同一个服务端根证书。


2016年2月21日 13:46 | # | 引用








bencanber 说：




引用古明地恋的发言：
您好，我有一个疑问。第一步是用服务器公钥加密的。而服务器公钥包含在证书中。但是如果入侵者获取到服务器证书，并用于解密之后的key，再用key来解密通信内容，这样怎么防范？

解密只能使用服务器的私钥解密，而证书中只包含服务器的公钥，所以不会被破解



2016年2月22日 15:07 | # | 引用








pengfei 说：



我有个疑问，比如我控制着代理服务器我知道 协商协议版本都是1.0 我也知道三次随机数第一次客户给服务器的 10，第二次服务器给客户端的 1050 第三次客户端给服务器的119，然后还知道他们协商的加密算法 RSA. 那我就可以自己按照加密算法RSA，用我看到的三个随机数生成一个秘钥了，这样我不是还是可以解开你的通信内容吗？



2016年3月 3日 12:01 | # | 引用








andy_chen 说：



"握手阶段"的所有通信都是明文的。对于这个，不知我的理解可否正确？1.客户端->服务器：随机数，支持的加密方法2.服务器->客户端：随机数，确定加密方法3.客户端->服务器：随机数（公钥加密）
这样，第一第二的随机数虽然可能被其他人截取，但是由于第三个随机数是通过公钥加密的，所以，只有对应的私钥可以解密，是安全的。
所以通过这三个随机数以及第二步确定的对称加密的方法，客户端以及服务端各自生成对话密钥。之后就通过这个对话密钥来进行通信



2016年3月 3日 14:39 | # | 引用






