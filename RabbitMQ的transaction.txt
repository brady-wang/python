RabbitMQ的transaction、confirm、ack三个概念的解释
在使用RabbitMQ的过程中，肯定会遇到这样的几个概念：transaction、confirm、ack。本文介绍一下这几个概念，以及他们之间的关系。
RabbitMQ是采用的AMQP协议，AMQP协议定义了”确认”（acknowledgement）,它是从consumer到RabbitMQ的确认，表示一条消息已经被客户端正确处理。RabbitMQ扩展了AMQP协议，定义了从broker到publisher的”确认”，但将其称之为confirm。所以RabbitMQ的确认有2种，叫不同的名字，一个consumer acknowledgement，一个叫publisher confirm。
根据AMQP协议规定，consumer acknowledgemenet是通过basic.ack方法实现的，consumer在收到一条消息后，可以向broker发送basic.ack方法，确认一条消息已经收到。在默认的情况下，consumer acknowledgement模式是开启的，如果不想发送basic.ack，可以在发送basic.consume方法时指定no-ack参数，关闭consumer acknowledgement模式。
Publisher confirm并没有在AMQ协议的基础上添加新的确认方法，而是复用了basic.ack方法。但是publisher confirm模式并不是默认打开的，需要调用confirm.select方法将channel设置成confirm模式。当开启了confirm模式之后，只有当一条消息被所有的mirrors接受之后，publisher才会收到这条消息的confirm，也就是一个basic.ack方法。
RabbitMQ支持事务(transaction)。事务模式也不是默认开启的，需要调用tx.select方法开启事务模式。当开启了事务模式后，只有当一个事务被所有的mirrors接受之后，tx.commit-ok才会返回给客户端。confirm模式和开启事务模式都可以保证”被所有的mirrors接受”，那么，开启confirm模式和开启事务模式有什么区别吗？不同点在于confirm是针对一条消息的，而事务是可以针对多条消息的（当然是针对同一个queue的多条消息）。另外就是，confirm模式只是针对publisher的设置，而事务模式即可以针对publisher，也可以针对consumer。如果针对publisher设置事务模式，则我们可以将多个basic.publish方法放在一个事务中，当所有的publish的消息被所有的mirrors接受后，publisher client会收到tx.commit-ok的方法。如果针对consumer设置事务模式，则我们可以将多个basic.ack方法放在一个事务中，收到tx.commit-ok时表示这些消息都被确认了。
